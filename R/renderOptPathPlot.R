#' Function for plotting optimization paths.
#'
#' @param op [\code{OptPath}]\cr
#'   Optimization path.
#' @param iter [\code{integer(1)}]\cr
#'   Selected iteration of \code{x} to render plots for.
#' @param x.over.time [\code{list} | NULL]
#'   List of vectors of x-variables, either specified via name or id. Maximum
#'   length for each vector is 5. For each list-element a line-plot iteration
#'   versus variable is generated. If the vector has length > 2 only mean values
#'   per iteration are plotted as lines, if vector has length 1 every point is
#'   plotted. Default is to plot all variables into as few plots as possible.
#'   Note that discrete variables are converted to numeric, if specified in the
#'   same vector with numerics. Moreover, if more than 1 point per iteration
#'   exists, mean values are calculated. This is also done for factor variables!
#'   We recommend you to specify  this argument in a useful way.
#' @param y.over.time [\code{list} | NULL]
#'   List of vectors of y-variables, either specified via name or id. Maximum
#'   length for each vector is 5. For each list-element a line-plot iteration
#'   versus variable is generated. If the vector has length > 2 only mean values
#'   per iteration are plotted as lines, if vector has length 1 every point is
#'   plotted. Default is to plot all variables into as few plots as possible.
#'   Note that discrete variables are converted to numeric, if specified in the
#'   same vector with numerics. Moreover, if more than 1 point per iteration
#'   exists, mean values are calculated. This is also done for factor variables!
#'   We recommend you to specify  this argument in a useful way.
#' @template arg_opplotter_lims
#' @param alpha [\code{logical(1)}]\cr
#'   Activates or deactivates the alpha fading for the plots. Default is \code{TRUE}.
#' @param colours [\code{character(4)}]\cr
#'   Colours of the points/lines for the four point types init, seq, prob and marked.
#'   Default is red for init, blue for seq, green for prob and orange for marked.
#' @param size.points [\code{numeric(4)} | NULL]\cr
#'   Size of points in the plot, default is 3. 
#' @param size.lines [\code{numeric(4)} | NULL]\cr
#'   Size of lines in the plots, default is 1.5. 
#' @param impute.scale [\code{numeric(1)}]\cr
#'   Numeric missing values will be replaced by \code{max + impute.scale * (max - min)}.
#'   Default is \code{1}.
#' @param impute.value [\code{character(1)}]\cr
#'   Factor missing values will be replaced by \code{impute.value}. Default is \code{missing}. 
#' @param scale [\code{character(1)}]\cr
#'   Parameter \code{scale} from the function \code{GGally::ggparcoord} which is used for 
#'   the multiD-case. Default is \code{std}.   
#' @param ggplot.theme
#'   Theme for the ggplots. Can be generated by \code{ggplot2::theme()}. Default is 
#'   \code{ggplot2::theme(legend.position = "top")}.
#' @param marked [\code{integer} | \code{character(1)} | NULL]\cr
#'    "best" or indices of points that should be marked in the plots.
#'    If \code{marked = "best"} the best point for single crit optimization 
#'    respectively the pareto front for multi crit optimization is marked. 
#'    Default is \code{NULL} (no points are marked).
#' @param subset.obs [\code{integer}]\cr
#'   Vector of indices to subset of observations to be plotted, default is all observations.
#'   All indices must be available in the opt.path. But, to enable subsetting over multiple
#'   iterations, not all indices must be available in the current iteration.
#'   Indices not available in the current iteration will be ignored. Default is all observations.
#' @param subset.vars [\code{integer} | \code{character}]\cr
#'   Subset of variables (x-variables) to be plotted. Either vector of indices or names. 
#'   Default is all variables.
#' @param subset.targets [\code{integer} | \code{character}]\cr
#'   Subset of target variables (y-variables) to be plotted. Either vector of indices or names. 
#'   Default is all variables
#' @param short.x.names [\code{character}]\cr
#'   Short names for x variables that are used as axis labels. Note you can
#'   only give shortnames for variables you are using in \code{subset.vars}
#' @param short.y.names [\code{character}]\cr
#'   Short names for y variables that are used as axis labels. Note you can
#'   only give shortnames for variables you are using in \code{subset.targets}
#' @return List of plots. If both X and Y space are 1D, list has length 1,
#'   otherwise length 2 with one plot for X and Y space respectivly.
#' @export
renderOptPathPlot = function(op, iter, x.over.time, y.over.time,
  xlim = list(), ylim = list(), alpha = TRUE, 
  colours = c("red", "blue", "green", "orange"), size.points = 3, size.lines = 1.5, impute.scale = 1, 
  impute.value = "missing", scale = "std", ggplot.theme = ggplot2::theme(legend.position = "top"), 
  marked = NULL, subset.obs, subset.vars, subset.targets, short.x.names, short.y.names) {
  
  requirePackages(c("GGally", "ggplot2"), why = "renderOptPathPlot")
  
  iters.max = max(getOptPathDOB(op))
  assertClass(op, "OptPath")
  assertInt(iter, lower = 0L, upper = iters.max)
  assertFlag(alpha)
  assertCharacter(colours, len = 4L)
  assertNumber(size.points)
  assertNumber(size.points)
  assertNumber(impute.scale)
  assertCharacter(impute.value, len = 1)
  assertChoice(scale, choices = c("std", "robust", "uniminmax", "globalminmax", "center", "centerObs"))
  assertClass(ggplot.theme, classes = c("theme", "gg"))
  
  if (!is.null(marked)) {
    if (is.character(marked)) {
      if (marked != "best")
        stop("Marked must either be 'best' or an integerish vector.")
    } else {
      marked = asInteger(marked)
    }
  }
  
  # Get Plotting Data
  data = getAndSubsetPlotData(op, iter, subset.obs, subset.vars, subset.targets,
    marked, alpha, impute.scale, impute.value)
  op.x = data$op.x
  op.y = data$op.y
  dob = data$dob
  .alpha = data$.alpha
  .type = data$.type
  x.names = data$x.names
  y.names = data$y.names
  dim.x = length(data$x.names)
  dim.y = length(data$y.names)
  
  if (missing(short.x.names)) {
    short.x.names = x.names
  } else {
    assertCharacter(short.x.names, len = length(x.names))
  }
  
  if (missing(short.y.names)) {
    short.y.names = y.names
  } else {
    assertCharacter(short.y.names, len = length(y.names))
  }
  
  # set and check x and y lims, if needed
  lims = getOptPathLims(xlim, ylim, op.x, op.y, iter, 0.05)
  xlim = lims$xlim
  ylim = lims$ylim
  
  # Some more argument checking and settign of defaults, based on the plotting data:
  if (missing(x.over.time)) {
    x.over.time = split(x.names, rep(1:ceiling(dim.x / 5), each = 5,
      length.out = dim.x))
  } else {
    assertList(x.over.time)
    for (vec in x.over.time) {
      if (is.character(vec))
        assertSubset(x = vec, choices = x.names, empty.ok = FALSE)
      else
        assertNumeric(x = vec, lower = 1L, upper = dim.x, any.missing = FALSE, unique = TRUE)
    }
  }
  
  if (missing(y.over.time)) {
    y.over.time = split(y.names, rep(1:ceiling(dim.y / 5), each = 5,
      length.out = dim.y))
  } else {
    assertList(y.over.time)
    for (vec in y.over.time) {
      if (is.character(vec))
        assertSubset(x = vec, choices = y.names, empty.ok = FALSE)
      else
        assertNumeric(x = vec, lower = 1L, upper = dim.y, any.missing = FALSE, unique = TRUE)
    }
  }

  # get classes of params (numeric or factor)
  classes.x = BBmisc::vcapply(op.x, function(x) class(x))
  classes.y = BBmisc::vcapply(op.y, function(x) class(x))
  
  # Special case: X and Y are 1D
  if(dim.x == 1L && dim.y == 1L) {
    pl = plot2D(cbind(x = op.x, y = op.y), .alpha, .type, names = c(x.names, y.names), 
      short.names = c(short.x.names, short.y.names), space = "both", iter = iter, 
      classes = c(classes.x, classes.y), xlim = xlim[["XSpace"]], ylim = xlim[["YSpace"]], 
      colours = colours, size = size.points, ggplot.theme = ggplot.theme)
    return(list(plot = pl))
  }
  
  # plot 1: x-space
  if (dim.x == 1L && classes.x == "numeric") {
    pl1 = plot1DNum(op.x, .alpha, .type, names = x.names, short.names = short.x.names, 
      space = "x", iter = iter, xlim = xlim[["XSpace"]], colours = colours, 
      ggplot.theme = ggplot.theme)
  }
  if (dim.x == 1L && classes.x == "factor") {
    pl1 = plot1DDisc(op.x, .alpha, .type, names = x.names, short.names = short.x.names, 
      space = "x", iter = iter, ylim = ylim[["XSpace"]], colours = colours, 
      ggplot.theme = ggplot.theme)
  }
    
  if (dim.x == 2L) {
    pl1 = plot2D(op.x, .alpha, .type, names = x.names, short.names = short.x.names, 
      space = "x", iter = iter, classes = classes.x, xlim = xlim[["XSpace"]], 
      ylim = ylim[["XSpace"]], colours = colours, size = size.points, ggplot.theme = ggplot.theme)
  } 
  if (dim.x > 2L) {
    pl1 = plotMultiD(op.x, .alpha, .type, names = x.names, short.names = short.x.names, 
      space = "x", iter = iter, colours = colours, size = size.lines, scale = scale, 
      ggplot.theme = ggplot.theme)
  }
  
  # plot 2: y-space
  if (dim.y == 1L && classes.y == "numeric") {
    pl2 = plot1DNum(op.y, .alpha, .type, names = y.names, short.names = short.y.names, 
      space = "y", iter = iter, xlim = xlim[["YSpace"]], colours = colours, 
      ggplot.theme = ggplot.theme)
  }
  if (dim.y == 1L && classes.y == "factor") {
    pl2 = plot1DDisc(op.y, .alpha, .type, names = y.names, short.names = short.y.names, 
      space = "y", iter = iter, ylim = ylim[["YSpace"]], colours = colours, 
      ggplot.theme = ggplot.theme)
  }
  
  if (dim.y == 2L) {
    pl2 = plot2D(op.y, .alpha, .type, names = y.names, short.names = short.y.names, 
      space = "y", iter = iter, classes = classes.y, xlim = xlim[["YSpace"]], 
      ylim = ylim[["YSpace"]], colours = colours, size = size.points, ggplot.theme = ggplot.theme)
  } 
  if (dim.y > 2L) {
    pl2 = plotMultiD(op.y, .alpha, .type, names = y.names, short.names = short.y.names, 
      space = "y", iter = iter, colours = colours, size = size.lines, scale = scale, 
      ggplot.theme = ggplot.theme)
  }
  
  # plot 3: x space over time
  pl3 = vector(mode = "list", length = length(x.over.time))
  for (i in seq_along(x.over.time)) {
    vars = x.over.time[[i]]
    if (is.character(vars))
      var.inds = which(names(op.x) %in% vars)
    
    if (length(vars) == 1) {
      pl3[[i]] = oneVariableOverTime(op = op.x, .alpha = .alpha, .type = .type, dob = dob,
        name = x.names[var.inds], short.name = short.x.names[var.inds], iter = iter,
        xlim = c(NA_real_, NA_real_), colours = colours, size.points = size.points,
        size.lines = size.lines, ggplot.theme = ggplot.theme)
    } else {
      pl3[[i]] = multiVariablesOverTime(op = op.x, .alpha = .alpha, dob = dob,
        names = x.names[var.inds], short.names = short.x.names[var.inds], space = "XSpace",
        iter = iter, lim.y = c(NA_real_, NA_real_), colours = colours, ggplot.theme = ggplot.theme)
    }
  }
  
  # plot 4: x space over time
  pl4 = vector(mode = "list", length = length(y.over.time))
  for (i in seq_along(y.over.time)) {
    vars = y.over.time[[i]]
    if (is.character(vars))
      var.inds = which(names(op.y) %in% vars)
    
    if (length(vars) == 1) {
      pl4[[i]] = oneVariableOverTime(op = op.y, .alpha = .alpha, .type = .type, dob = dob,
        name = y.names[var.inds], short.name = short.y.names[var.inds], iter = iter,
        xlim = c(NA_real_, NA_real_), colours = colours, size.points = size.points,
        size.lines = size.lines, ggplot.theme = ggplot.theme)
    } else {
      pl4[[i]] = multiVariablesOverTime(op = op.y, .alpha = .alpha, dob = dob,
        names = y.names[var.inds], short.names = short.y.names[var.inds], space = "YSpace",
        iter = iter, lim.y = c(NA_real_, NA_real_), colours = colours, ggplot.theme = ggplot.theme)
    }
  }
  
  return(list(plot.x = pl1, plot.y = pl2, plot.x.over.time = pl3, plot.y.over.time = pl4))
}
