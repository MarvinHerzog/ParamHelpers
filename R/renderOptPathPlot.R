#' Functions for plotting optimization paths.
#'
#' @param op [\code{OptPath}]\cr
#'   Optimization path.
#' @param iter [\code{integer(1)}]\cr
#'   Selected iteration of \code{x} to render plots for.
#' @template arg_opplotter_lims
#' @param alpha [\code{logical(1)}]\cr
#'   Activates or deactivates the alpha fading for the plots. Default is \code{TRUE}.
#' @param colours [\code{character(4)}]\cr
#'   Colours of the points/lines for the four point types init, seq, prob and marked.
#'   Default is red for init, blue for seq, green for prob and orange for marked.
#' @param size.points [\code{numeric(4)} | NULL]\cr
#'   Size of points in the plot, default is 3. 
#' @param size.lines [\code{numeric(4)} | NULL]\cr
#'   Size of lines in the plots, default is 1.5. 
#' @param impute.scale [\code{numeric(1)}]\cr
#'   Numeric missing values will be replaced by \code{max + impute.scale * (max - min)}.
#'   Default is \code{1}.
#' @param impute.value [\code{character(1)}]\cr
#'   Factor missing values will be replaced by \code{impute.value}. Default is \code{missing}. 
#' @param scale [\code{character(1)}]\cr
#'   Parameter \code{scale} from the function \code{GGally::ggparcoord} which is used for 
#'    the multiD-case. Default is \code{std}.   
#' @param ggplot.theme
#'   Theme for the ggplots. Can be generated by \code{ggplot2::theme()}. Default is 
#'   \code{ggplot2::theme(legend.position = "top")}.
#' @param marked [\code{integer} | \code{character(1)} | NULL]\cr
#'    "best" or indices of points that should be marked in the plots.
#'    If \code{marked = "best"} the best point for single crit optimization 
#'    respectively the pareto front for multi crit optimization is marked. 
#'    Default is \code{NULL} (no points are marked).
#' @param subset.obs [\code{integer}]\cr
#'   Vector of indices to subset of observations to be plotted, default is all observations.
#'   All indices must be available in the opt.path. But, to enable subsetting over multiple
#'   iterations, not all indices must be available in the current iteration.
#'   Indices not available in the current iteration will be ignored. Default is all observations.
#' @param subset.vars [\code{integer} | \code{character}]\cr
#'   Subset of variables (x-variables) to be plotted. Either vector of indices or names. 
#'   Default is all variables
#' @param subset.targets [\code{integer} | \code{character}]\cr
#'   Subset of target variables (y-variables) to be plotted. Either vector of indices or names. 
#'   Default is all variables
#' @param short.x.names [\code{character}], @param short.y.names [\code{character}]\cr
#'   Short names for x or y variables that are used as axis labels.
#' @return List of plots. If both X and Y space are 1D, list has length 1,
#'   otherwise length 2 with one plot for X and Y space respectivly.
#' @export
renderOptPathPlot = function(op, iter, xlim = list(), ylim = list(), alpha = TRUE, 
    colours = c("red", "blue", "green", "orange"), size.points = 3, size.lines = 1.5, impute.scale = 1, 
    impute.value = "missing", scale = "std", ggplot.theme = ggplot2::theme(legend.position = "top"), 
    marked = NULL, subset.obs, subset.vars, subset.targets, short.x.names, short.y.names) {
  
  requirePackages(c("GGally", "ggplot2"), why = "renderOptPathPlot")
  
  iters.max = max(getOptPathDOB(op))
  assertInt(iter, lower = 0L, upper = iters.max)
  assertFlag(alpha)
  assertCharacter(colours, len = 4L)
  assertNumber(size.points)
  assertNumber(size.points)
  assertNumber(impute.scale)
  assertCharacter(impute.value, len = 1)
  assertChoice(scale, choices = c("std", "robust", "uniminmax", "globalminmax", "center", "centerObs"))
  assertClass(ggplot.theme, classes = c("theme", "gg"))
  
  if (!is.null(marked)) {
    if (is.character(marked)) {
      if (marked != "best")
        stop("Marked must either be 'best' or an integerish vector.")
    } else {
      marked = asInteger(marked)
    }
  }
  
  x.names = colnames(getOptPathX(op))
  if (missing(short.x.names)) {
    short.x.names = x.names
  } else {
    assertCharacter(short.x.names, len = length(x.names))
  }

  y.names = op$y.names
  if (missing(short.y.names)) {
    short.y.names = y.names
  } else {
    assertCharacter(short.y.names, len = length(y.names))
  }
  
  # Get Plotting Data
  data = getAndSubsetPlotData(op, iter, subset.obs, subset.vars, subset.targets,
    marked, alpha)
  op.x = data$op.x
  op.y = data$op.y
  dob = data$dob
  .alpha = data$.alpha
  .type = data$.type
  dim.x = length(data$subset.vars)
  dim.y = length(data$subset.targets)
  
  # impute missing values
  op.x = BBmisc::dapply(op.x, fun = imputeMissingValues, impute.scale = impute.scale,
    impute.value = impute.value)
  op.y = BBmisc::dapply(op.y, fun = imputeMissingValues, impute.scale = impute.scale,
    impute.value = impute.value)

  # get classes of params (numeric or factor)
  classes.x = BBmisc::vcapply(op.x, function(x) class(x))
  classes.y = BBmisc::vcapply(op.y, function(x) class(x))
  
  # set and check x and y lims, if needed
  lims = getOptPathLims(xlim, ylim, op.x, op.y, iter, 0.05)
  xlim = lims$xlim
  ylim = lims$ylim
  
  # Special case: X and Y are 1D
  if(dim.x == 1L && dim.y == 1L) {
    pl = plot2D(cbind(x = op.x, y = op.y), .alpha, .type, names = c(x.names, y.names), 
      short.names = c(short.x.names, short.y.names), space = "both", iter = iter, 
      classes = c(classes.x, classes.y), xlim = xlim[["XSpace"]], ylim = xlim[["YSpace"]], 
      colours = colours, size = size.points, ggplot.theme = ggplot.theme)
    return(list(plot = pl))
  }
  
  # plot 1: x-space
  if (dim.x == 1L && classes.x == "numeric") {
    pl1 = plot1DNum(op.x, .alpha, .type, names = x.names, short.names = short.x.names, 
      space = "x", iter = iter, xlim = xlim[["XSpace"]], colours = colours, 
      ggplot.theme = ggplot.theme)
  }
  if (dim.x == 1L && classes.x == "factor") {
    pl1 = plot1DDisc(op.x, .alpha, .type, names = x.names, short.names = short.x.names, 
      space = "x", iter = iter, ylim = ylim[["XSpace"]], colours = colours, 
      ggplot.theme = ggplot.theme)
  }
    
  if (dim.x == 2L) {
    pl1 = plot2D(op.x, .alpha, .type, names = x.names, short.names = short.x.names, 
      space = "x", iter = iter, classes = classes.x, xlim = xlim[["XSpace"]], 
      ylim = ylim[["XSpace"]], colours = colours, size = size.points, ggplot.theme = ggplot.theme)
  } 
  if (dim.x > 2L) {
    pl1 = plotMultiD(op.x, .alpha, .type, names = x.names, short.names = short.x.names, 
      space = "x", iter = iter, colours = colours, size = size.lines, scale = scale, 
      ggplot.theme = ggplot.theme)
  }
  
  # plot 2: y-space
  if (dim.y == 1L && classes.y == "numeric") {
    pl2 = plot1DNum(op.y, .alpha, .type, names = y.names, short.names = short.y.names, 
      space = "y", iter = iter, xlim = xlim[["YSpace"]], colours = colours, 
      ggplot.theme = ggplot.theme)
  }
  if (dim.y == 1L && classes.y == "factor") {
    pl2 = plot1DDisc(op.y, .alpha, .type, names = y.names, short.names = short.y.names, 
      space = "y", iter = iter, ylim = ylim[["YSpace"]], colours = colours, 
      ggplot.theme = ggplot.theme)
  }
  
  if (dim.y == 2L) {
    pl2 = plot2D(op.y, .alpha, .type, names = y.names, short.names = short.y.names, 
      space = "y", iter = iter, classes = classes.y, xlim = xlim[["YSpace"]], 
      ylim = ylim[["YSpace"]], colours = colours, size = size.points, ggplot.theme = ggplot.theme)
  } 
  if (dim.y > 2L) {
    pl2 = plotMultiD(op.y, .alpha, .type, names = y.names, short.names = short.y.names, 
      space = "y", iter = iter, colours = colours, size = size.lines, scale = scale, 
      ggplot.theme = ggplot.theme)
  }
  
  return(list(plot.x = pl1, plot.y = pl2))
}
