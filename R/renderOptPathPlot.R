#' Functions for plotting optimization paths.
#'
#' @param op [\code{OptPath}]\cr
#'   Optimization path.
#' @param iter [\code{integer(1)} | NULL]\cr
#'   Selected iteration of \code{x} to render plots for.
#' @param lim.x [\code{list}], @param lim.y [\code{list}]\cr
#'   Axis limits for the plots. Must be a named list, so you can specify the
#'   axis limits for every plot. Every element of the list must be a numeric
#'   vector of length 2. Available names for elements are:
#'   XSpace - limits for the X-Space plot
#'   YSpace - limits for the Y-Space plot
#'   Default is an empty list - in this case limits are automatically set.  
#' @param alpha [\code{logical(1)}]\cr
#'   Activates or deactivates the alpha fading for the plots. Default is \code{TRUE}.
#' @param colours [\code{character(4)}]\cr
#'   Colours of the points/lines for the three point types init, seq, prob and marked.
#' @param size [\code{numeric(2)} | NULL]\cr
#'   Size of points (1st entry of \code{size}) or lines (2nd entry of \code{size}).
#'   The default is \code{c(3, 1.5)}. 
#' @param impute.scale [\code{numeric(1)}]\cr
#'   Numeric missing values will be replaced by \code{max + impute.scale * (max - min)}.
#'   Default is \code{1}.
#' @param impute.value [\code{character(1)}]\cr
#'   Factor missing values will be replaced by \code{impute.value}. Default is \code{missing}. 
#' @param scale [\code{character(1)}]\cr
#'   Parameter \code{scale} from the function \code{GGally::ggparcoord} which is used for 
#'    the multiD-case. Default is \code{std}.   
#' @param ggplot.theme
#'   Theme for the ggplots. Can be generated by \code{ggplot2::theme()}. Default is 
#'   \code{ggplot2::theme(legend.position = "top")}.
#' @param marked [\code{integer} | \code{character(1)} | NULL]\cr
#'    "best" or indices of points that should be marked in the plots.
#'    If \code{marked = "best"} the best point for single crit optimization 
#'    respectively the pareto front for multi crit optimization is marked. 
#'    Default is \code{NULL} (no points are marked).
#' @param subset.obs [\code{integer}]\cr
#'   Vector of indices to subset of observations to be plotted, default is all observations.
#'   All indices must be available in the opt.path, but not in the current iteration.
#'   Indices not available in the current iteration will be ignored.
#' @param subset.vars [\code{integer} | \code{character}]\cr
#'   Subset of variables (x-variables) to be plotted. Either vector of indices or names. 
#'   Default is all variables
#' @param subset.targets [\code{integer} | \code{character}]\cr
#'   Subset of target variables (y-variables) to be plotted. Either vector of indices or names. 
#'   Default is all variables
#' @param short.x.names [\code{character}], @param short.y.names [\code{character}]\cr
#'   Short names for x or y variables that are used as axis labels.
#' @return List of plots. If both X and Y space are 1D, list has length 1,
#'   otherwise length 2 with one plot for X and Y space respectivly.
#' @export
renderOptPathPlot = function(op, iter, lim.x = list(), lim.y = list(), alpha = TRUE, 
    colours = c("red", "blue", "green", "orange"), size = c(3, 1.5), impute.scale = 1, 
    impute.value = "missing", scale = "std", ggplot.theme = ggplot2::theme(legend.position = "top"), 
    marked = NULL, subset.obs, subset.vars, subset.targets, short.x.names, short.y.names) {
  
  requirePackages("GGally", why = "renderOptPathPlot")
  requirePackages("ggplot2", why = "renderOptPathPlot")
  
  iters.max = max(getOptPathDOB(op))
  assertIntegerish(iter, len = 1L, lower = 0L, upper = iters.max, any.missing = FALSE)
  assertFlag(alpha)
  assertCharacter(colours, len = 4)
  assertNumeric(size, len = 2)
  assertNumeric(impute.scale, len = 1)
  assertCharacter(impute.value, len = 1)
  assertChoice(scale, choices = c("std", "robust", "uniminmax", "globalminmax", "center", "centerObs"))
  assertClass(ggplot.theme, classes = c("theme", "gg"))
  
  if (!is.null(marked)) {
    if (is.character(marked)) {
      assertChoice(marked, choices = c("best"))
    } else {
      marked = asInteger(marked)
    }
  }
  
  x.names = colnames(getOptPathX(op))
  if (missing(short.x.names)) {
    short.x.names = x.names
  } else {
    assertCharacter(short.x.names, len = length(x.names))
  }
  dim.x = length(x.names)

  y.names = op$y.names
  if (missing(short.y.names)) {
    short.y.names = y.names
  } else {
    assertCharacter(short.y.names, len = length(y.names))
  }
  dim.y = length(y.names)
  
  # Get Plotting Data
  data = getAndSubsetPlotData(op, iter, subset.obs, subset.vars, subset.targets,
    marked, alpha)
  op.x = data$op.x
  op.y = data$op.y
  dob = data$dob
  .alpha = data$.alpha
  .type = data$.type
  dim.x = length(data$subset.vars)
  dim.y = length(data$subset.targets)
  
  # impute missing values
  op.x = BBmisc::dapply(op.x, fun = imputeMissingValues, impute.scale = impute.scale, impute.value = impute.value)
  op.y = BBmisc::dapply(op.y, fun = imputeMissingValues, impute.scale = impute.scale, impute.value = impute.value)

  # get classes of params (numeric or factor)
  classes.x = BBmisc::vcapply(op.x, function(x) class(x))
  classes.y = BBmisc::vcapply(op.y, function(x) class(x))
  
  # set and check x and y lims, if needed
  lims = getOptPathLims(lim.x, lim.y, op.x, op.y, iter, 0.05)
  lim.x = lims$lim.x
  lim.y = lims$lim.y
  
  # Special case: X and Y are 1D
  if(dim.x == 1L && dim.y == 1L) {
    pl = plot2D(cbind(x = op.x, y = op.y), .alpha, .type, names = c(x.names, y.names), 
      short.names = c(short.x.names, short.y.names), space = "both", iter = iter, 
      classes = c(classes.x, classes.y), lim.x = lim.x[["XSpace"]], lim.y = lim.x[["YSpace"]], 
      colours = colours, size = size[1], ggplot.theme = ggplot.theme)
    return(list(plot = pl))
  }
  
  # plot 1: x-space
  if (dim.x == 1L && classes.x == "numeric") {
    pl1 = plot1DNum(op.x, .alpha, .type, names = x.names, short.names = short.x.names, 
      space = "x", iter = iter, lim.x = lim.x[["XSpace"]], colours = colours, 
      ggplot.theme = ggplot.theme)
  }
  if (dim.x == 1L && classes.x == "factor") {
    pl1 = plot1DDisc(op.x, .alpha, .type, names = x.names, short.names = short.x.names, 
      space = "x", iter = iter, lim.y = lim.y[["XSpace"]], colours = colours, 
      ggplot.theme = ggplot.theme)
  }
    
  if (dim.x == 2L) {
    pl1 = plot2D(op.x, .alpha, .type, names = x.names, short.names = short.x.names, 
      space = "x", iter = iter, classes = classes.x, lim.x = lim.x[["XSpace"]], 
      lim.y = lim.y[["XSpace"]], colours = colours, size = size[1], ggplot.theme = ggplot.theme)
  } 
  if (dim.x > 2L) {
    pl1 = plotMultiD(op.x, .alpha, .type, names = x.names, short.names = short.x.names, 
      space = "x", iter = iter, colours = colours, size = size[2], scale = scale, 
      ggplot.theme = ggplot.theme)
  }
  
  # plot 2: y-space
  if (dim.y == 1L && classes.y == "numeric") {
    pl2 = plot1DNum(op.y, .alpha, .type, names = y.names, short.names = short.y.names, 
      space = "y", iter = iter, lim.x = lim.x[["YSpace"]], colours = colours, 
      ggplot.theme = ggplot.theme)
  }
  if (dim.y == 1L && classes.y == "factor") {
    pl2 = plot1DDisc(op.y, .alpha, .type, names = y.names, short.names = short.y.names, 
      space = "y", iter = iter, lim.y = lim.y[["YSpace"]], colours = colours, 
      ggplot.theme = ggplot.theme)
  }
  
  if (dim.y == 2L) {
    pl2 = plot2D(op.y, .alpha, .type, names = y.names, short.names = short.y.names, 
      space = "y", iter = iter, classes = classes.y, lim.x = lim.x[["YSpace"]], 
      lim.y = lim.y[["YSpace"]], colours = colours, size = size[1], ggplot.theme = ggplot.theme)
  } 
  if (dim.y > 2L) {
    pl2 = plotMultiD(op.y, .alpha, .type, names = y.names, short.names = short.y.names, 
      space = "y", iter = iter, colours = colours, size = size[2], scale = scale, 
      ggplot.theme = ggplot.theme)
  }
  
  return(list(plot.x = pl1, plot.y = pl2))
}
